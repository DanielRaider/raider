%chapter introduce un nuevo capítulo
\chapter{Programación TODO}

En este capítulo se presenta el desarrollo de todo el software que ha sido requerido preparar para la puesta en marcha del robot.

\section{Configuración de la BeagleBone Black}

El controlador principal, la BeagleBone Black, trae de fábrica una instalación de una distribución Ångström basada en Linux. El sistema operativo incluye: entorno gráfico, escritorio, OpenCV 2.2 y otros programas como navegadores o reproductores de archivos multimedia. Esto se debe a que la BeagleBone Black no es una placa que de fábrica esté pensada para su uso en robots, sino que constituye un ordenador completo que puede adquirir la función de centro multimedia, equipo de ofimática o incluso servidor de una red.

\subsection{Sistema operativo}

La distribución Ångström no es una de las más populares entre los sistemas operativos basados en Linux, no cuenta con una comunidad de usuarios tan amplia como Debian o Fedora. Por ello, las actualizaciones no suelen ser muy frecuentes y, en muchos casos, el sistema presenta errores de funcionamiento a la hora de realizar tareas básicas, como la instalación de nuevo software.

\medskip Por esta razones se ha decidido instalar un nuevo sistema operativo. Se pretende conseguir una distribución de Linux que solo tenga lo mínimo necesario que requiere el robot para su funcionamiento. Con este objetivo, se instala en la BeagleBone Black una distribución Debian.

\subsection{Instalación de librerías}

Para la realización del proyecto, se ha requerido instalar Git, CMake, Video4Linux2 y las librerías de OpenCV 2.4.8 y ZBar 0.1.

\medskip Antes de comenzar con la instalación de software, es recomendable realizar una actualización del sistema ejecutando los siguientes comandos:

\begin{verbatim}
sudo apt-get update
sudo apt-get upgrade
\end{verbatim}

\bigskip  Lo primero que instalaremos será Git, ya que lo necesitaremos para instalar algunas librarías posteriormente. Git se instala ejecutando el siguiente comando: 
\begin{verbatim}
sudo apt-get install git-core
\end{verbatim}

\bigskip Para instalar CMake lo haremos de la siguiente forma:

\begin{verbatim}
sudo apt-get install cmake
sudo apt-get install cmake-curses-gui
\end{verbatim}

\bigskip Para el control y configuración de la webcam se necesitará el driver Video4Linux. Se instalará como se muestra a continuación:

\begin{verbatim}
sudo apt-get install v4l-utils
\end{verbatim}


\bigskip  Una vez hecho esto, se pasará a instalar las librerías que se utilizarán en el código del robot. La forma mas sencilla de instalar Zbar será hacerlo desde los repositorios de Debian. De este modo, ejecutaremos los siguientes comandos:
\begin{verbatim}
sudo apt-get install libzbar0
sudo apt-get install libzbar-dev
\end{verbatim}

\bigskip  Por último, instalaremos OpenCV. Se comenzará por descargar todas las librarías que requiere OpenCV. Se instalarán una a una de la siguiente forma:
\begin{verbatim}
sudo apt-get install build-essential 
sudo apt-get install libgtk2.0-dev 
sudo apt-get install pkg-config 
sudo apt-get install python-dev 
sudo apt-get install python-numpy 
sudo apt-get install libavcodec-dev 
sudo apt-get install libavformat-dev 
sudo apt-get install libswscale-dev
\end{verbatim}

Hecho esto, se procederá a descargar la última versión estable del código, que en este momento es la 2.4.9.

\begin{verbatim}
wget http://downloads.sourceforge.net/project/opencvlibrary/opencv-unix/2.4.9/opencv-2.4.9.zip
\end{verbatim}

\bigskip Y posteriormente se instalará de este modo:

\begin{verbatim}
unzip opencv-2.4.9.zip
cd opencv-2.4.9
mkdir build
cd build
cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local ..
make
sudo make install
\end{verbatim}

\subsection{Configuración de la cámara}

A continuación se configurará la webcam en la beaglebone. Para esto se conectará por USB la Microsoft Lifecam a la BeagleBone Black tal y como puede observarse en la figura \ref{robotbbbcam}. A partir de aquí, se iniciará sesión en la BeagleBone Black y se procederá a configurar la cámara.

\medskip Lo primero que se hará será comprobar que la cámara se ha reconocido correctamente. Para ello ejecutaremos el comando:

\begin{verbatim}
lsusb
\end{verbatim}

\bigskip Y deberá proporcionarnos una salida parecida a la que puede observarse en la figura \ref{lsusbbbb}. La salida indica que la webcam está conectada en el bus 001

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/lsusbbbb}   
\caption{Salida del comando lsusb}
\label{lsusbbbb}
\end{figure}

\medskip Para cerciorarno de que la cámara se ha reconocido correctamente podemos buscarla en el directorio /dev. En la siguiente imagen (figura \ref{lsdev}) se observa el archivo /dev/video0, que está vinculado a la webcam.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/lsdev}   
\caption{Comprobación de conexión para la webcam}
\label{lsdev}
\end{figure}

A continuación nos ayudaremos de las utilidades de Video4Linux (una interfaz para la programación de aplicaciones con captura de imágenes para Linux) para la webcam. OpenCV se apoya en Video4Linux, por tanto, lo primero que se hará será comprobar que la cámara es compatible con Video4Linux. Para ello, se ejecutará el siguiente comando:

\begin{verbatim}
v4l2-ctl --list-devices
\end{verbatim}

\bigskip Tras ejecutarlo se deberá observar una salida similar a la de la figura \ref{v4llist}

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/v4llist}   
\caption{Comprobación de compatibilidad para la webcam}
\label{v4llist}
\end{figure}

Ésto nos confirma que la cámara funciona correctamente. Para proseguir con la configuración vamos a ejecutar el comando siguiente:

\begin{verbatim}
v4l2-ctl --all
\end{verbatim}

\bigskip  En la figura \ref{v4lall} podemos observar la salida del comando. En ella se pueden observar diferentes parámetros como el formato de video, la resolución o los fotogramas por segundo.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/v4lall}   
\caption{Parámetros leídos de la cámara}
\label{v4lall}
\end{figure}

\medskip Por último, se bajará la resolución de la cámara a un valor que nos permita tratar las imágenes con mayor rapidez cuando se programen algoritmos de visión con OpenCV desde la BeagleBone Black. Se ha elegido una resolución de 320x240, mas adelante se ajustará este valor empíricamente en función del rendimiento del robot. Para ello ejecutamos este comando de configuración:

\begin{verbatim}
v4l2-ctl --set-fmt-video=width=320,heigth=240
\end{verbatim}

\bigskip  Tras estos pasos la cámara ya está preparada y lista para usarse.

%vdeo capture aplication progamin interface for linux

\subsection{Configuración de pines}

Para finalizar esta sección, se muestra el desarrollo de un script para configurar los pines del controlador.

\medskip La Beaglebone Black posee 92 pines configurables de entrada y salida. Entre ellos, 7 pueden funcionar como entradas analógicas y 5 parejas de pines están preparadas como puertos serie (figura \ref{bbbserial}).

\begin{figure}[H]
\centering
\includegraphics[width=1\textwidth]{figuras/bbbserial}   
\caption{Puertos serie en una BeagleBone Black}
\label{bbbserial}
\end{figure}

Para configurar los pines de la placa se utilizarán overlays (capas). Un overlay es un archivo que indica al sistema operativo cómo debe configurarse un pin. La BeagleBone Black se configura mediante Device Tree Overlays, un mecanismo de descripción del hardware que forma parte de un sistema. Para configurar las entradas analógicas necesarias para los sensores infrarrojos, y el puerto serie que comunicará la placa con el controlador de locomoción; se utilizarán los archivos \textit{.dtbo} que pueden encontrarse en \textit{/lib/firmware} (figura \ref{libfirmware})


\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/libfirmware}   
\caption{Algunas capas de Device Tree Overlays}
\label{libfirmware}
\end{figure}

\medskip En concreto se utilizarán dos capas, la que activará el puerto serie número 2: \textit{ttyO2\_armhf.com} y esta otra que nos permitirá activar las entradas analógicas: \textit{cape-bone-iio}. Se habilitarán de la siguiente manera (figura \ref{overlays}):

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/overlays}   
\caption{Habilitación de capas}
\label{overlays}
\end{figure}

\medskip Puede realizarse una comprobación simple de que los pines se han configurado correctamente realizando una lectura analógica. Para ello, se leerá el archivo \textit{/sys/bus/platform/drivers/bone-iio-helper/helper.15/AIN4}. En la figura \ref{catain4} se ha realizado una lectura del pin 4, el valor de 570 indica que se está realizando una lectura de $570mV$.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/catain}   
\caption{Lectura analógica del pin 4}
\label{catain4}
\end{figure}


\section{Sistema de locomoción TODO}

Antes de comenzar con esta sección, es importante señalar algunos detalles importantes. Si bien es cierto, el control del robot girará en torno a un algoritmo de visión, su funcionamiento de apoyará en un control de locomoción robusto que permita al robot realizar desplazamientos seguros sobre el terreno. Por tanto, dado que se trata de un robot bípedo, la programación de movimientos no es un tema trivial como lo podría ser en un robot con ruedas.

Para conseguir que Raider pueda moverse con soltura se han seguido varios pasos, cada cual de un nivel superior al anterior.

\subsection{Movimiento del servo PWM}
% aqui no explicar el principio de funcionamiento, solo la parte de programacion
% o sea, de Servo.write para arriba

El control del servo PWM de Raider, situado en su cabeza, se realiza con la biblioteca Servo.h orginalmente desarrolladas para Arduino y que posteriormente ha sido portada para su utilización en OpenCM. Dado el cometido de este servo, no será necesario realizar un control de su velocidad, por lo que un simple control de su posición será suficiente.

La biblioteca Servo.h nos permite controlar el movimiento de un servo a partir de un valor de posición, y se encarga de producir la señal PWM correspondiente. Aunque los métodos utilizados pueden encontrarse en la documentación de Arduino ( TODO ), a continuación introduzco una breve explicación de los que han sido utilizados en este proyecto:

\subsubsection{Servo::attach(uint8 pin)}

Con esta función configuramos un pin de la OpenCM para que actúe como emisora de señales PWM. A partir de esta inicialización ya puede moverse el servo.

\subsubsection{Servo::writeMicroseconds(uint16 pulseWidth)}

Para mover el servo se utiliza la función writeMicroseconds, cuyo parámetro define la amplitud  del pulso de la onda PWM. Si bien es cierto, existe otra función paralela llamada write(int angle) que directamente utiliza como parámetro la posición en grados, se ha utilizado writeMicroseconds por su mayor precisión. Acepta valores de entre 1000 y 2000 microsegundos, pero para mantener un formato constante con el resto de articulaciones, se ha realizado una conversión matemática a un rango de 0 a 1023.

\subsection{Movimiento de los actuadores Dynamixel}

Para comunicarse con los actuadores Dynamixel (de los que hablamos en TODO ) debemos utilizar su protocolo particular. Los servos son controlados mediante el envio de paquetes de datos binarios. Existen dos tipos de paquetes en el protocolo: Los paquetes de instrucciones, que son los que envia el controlador a los servos; y los paquetes de estado, que son los los servos envían al controlador.

\medskip 
Cada servo tiene una ID, o dicho de otra forma, un número de identidad propio e irrepetible que identifica a un servo particular dentro del bus. La comunicación en el bus se realiza mediante el intercambio de paquetes de instrucciones y estados con una ID concreta.
Por esta razón, en un mismo bus no deben existir servos con la misma ID, ya que provocarán colisiones entre los paquetes e impedirán el correcto funcionamiento del sistema. Sin embargo, estas ID son fácilmente reprogramables y pueden modificarse realizando una escritura sobre el registro 3 (0X03).

\medskip 
El protocolo de comunicación utilizado es una comunicación serie asíncrona de 8 bits, con 1 bit de Stop y sin paridad. La conexión, de tipo Half Duplex, no permite la transmision y recepción de paquetes de forma simultanea. Esto la convierte en una conexión bastante típica en los sistema que utilizan un solo bus de comunicación. Como en el mismo bus existe mas de un dispositivo, todos deben permanecer en modo de escucha salvo el que esté transmitiendo en ese instante. El controlador principal, la placa OpenCM 9.04, asigna la dirección del bus en modo escucha, y solo cambia la dirección del bus a modo de envio mientras manda un paquete. (TODO revisar) Los Dynamixel AX-12A poseen una tabla de registros (tabla TODO ) sobre la cual podemos modificar varios parámetros referente a su estado y su funcionamiento. La tabla de registros puede consultarse en TODO .

\medskip 
Para realizar una rotación simple en un servomotor, sería suficiente con escribir en el registro 32 (Goal Position) un valor comprendido entre 0 y 1023, y el servo se situará inmediatamente en esa posición. Sin embargo, existen otros parámetros interesantes en el mapa de registros que conviene controlar, como la posición instantanea, la velocidad de giro, el consumo eléctrico o incluso la temperatura del dispositivo.

\medskip 
Para mover los 19 AX-12A de Raider se utilizan los parámetros de posición objetivo (Goal Position) y velocidad de giro (Moving Speed) de forma combinada. Dado que está programación se ha realizado desde la OpenCM 9.04 se ha utilizado la biblioteca Dynamixel.h, que funciona como una macro para leer y escribir en los registros de forma sencilla y eficiente. Dentro de la biblioteca utilizaremos la función writeWord con la siguiente sintaxis:

% TODO arreglar codigos

\begin{verbatim}
Dxl.writeWord(
	Dynamixel_Motor_Number,	
	Address_Number,
	Address_Data
);
\end{verbatim}

A modo de ejemplo, para asignar una velocidad de $3.5rad/s$ al servo con la ID 5, primero calcularíamos el valor correspondiente para una resolución de 10 bits. Según el manual de los servos Dynamixel ( TODO citar) AX-12A, la velocidad máxima de estos servomotores es de $114rpm$. Por tanto, se realizaría la siguiente conversión:

\[ 3.5 \cdot \frac{rad}{s} \cdot \frac{60 s}{2 \pi rad} \cdot rpm \cdot \frac{1024}{114 rpm}= 300.216 \simeq 300 \]

\medskip
Dentro del código, utilizaremos la función writeWord para asignar este valor en el registro 32 (Moving Speed):

% TODO arreglar codigos
\begin{verbatim}
Dxl.writeWord(5,32,300);
\end{verbatim} 

Seguidamente, asignaríamos al servo una posición final siguiendo el criterio de la figura \ref{goalposition}

\begin{figure}[h]
\centering
\includegraphics[width=0.55\textwidth]{figuras/goalposition}   
\caption{Amplitud de giro de un AX-12A}
\label{goalposition}
\end{figure}

Continuando con el ejemplo, calcularemos el valor que debemos darle al registro para mover el servo a una posición de $120º$, teniendo en cuenta que las especificaciones nos indican una amplitud de giro total de 300º reales con una resolución de 10 bits. De esta forma, haríamos la siguiente conversión:

\[ 120º \cdot \frac{1024}{300º}= 409.6 \simeq 410 \]

\medskip
En nuestro programa escribiríamos en el registro 30 (Goal Position) de la siguiente forma:

% TODO arreglar codigos
\begin{verbatim}
Dxl.writeWord(5,30,410);
\end{verbatim} 

Como resumen, con estos pasos hemos conseguido mover el servo con la ID 5 (Que corresponde al codo del brazo izquierdo de Raider), a una posición de $120º$ con una velocidad de $3.5 rad/s$

\subsection{Movimiento sincronizado de las articulaciones}

En el apartado anterior se ha mostrado cómo se realiza el movimiento de un servo, sin embargo, para mover el cuerpo del robot necesitaremos mover todos al mismo tiempo de una forma sincronizada. Si en el apartado anterior utilizabamos la posición objetivo y la velocidad de movimiento como parámetros, en este punto, por comodidad a la hora de programar, utilizaremos como parámetros la posición objetivo de los 20 servos, su posición actual y el tiempo total durante el que se realizará su movimiento entre ambos puntos.

\medskip
Este es quizás uno de los apartados mas críticos a la hora de diseñar las funciones que moverán el robot. Se pretende programar una biblioteca que permita mover 20 servos simultaneamente, con velocidades diferentes condicionadas por un tiempo de ejecución común. De esta forma, los servos cuya posición objetivo sea lejana a su posición actual se moverán con una velocidad mayor que la de los servos cuya posición objetivo sea cercana a su posición actual.

\medskip
Las funciones pueden encontrarse en la biblioteca raider TODO motion.h

\subsubsection{class Robot} 

La clase Robot abarca todas las funciones relativas al movimiento de Raider (aunque por el momento en esta sección solo se presenta algunas de ellas), y abstrae su controlador principal, la BeagleBone Black de la parte de locomoción. Dentro de la clase, encontramos tres variables miembros importantes:

\begin{itemize}
\item \textbf{int currentPosition[20]}.

currentPosition es un array de 20 posiciones destinado a almacenar los valores de las posición actual de las 20 articulaciones del robot con valores comprendidos entre 0 y 1023. El primer valor es el servo AX-12A, el segundo es el servo PWM de la cabeza y a partir de ese punto están el resto de AX-12A ordenados según su ID, del número 1 al 18.

\item \textbf{int targetPostion[20]}.

targetPosition sigue la misma estructura de currentPosition, con la diferencia de que en este caso los valores guardados en el array corresponderán con la posición objetivo o posición final de las articulaciones.

\item \textbf{int TRIM[20]}.

Por último, TRIM es un array de trims. Un trims es una variable de ajuste para calibrar la posición de los servos. Tanto los servos Dynamixel como los servos PWM suelen tener un pequeño error en su posición cero. Los trimmers constituyen un offset aplicado individualmente a cada servo en absolutamente todos los movimientos que se realizarán durante el programa. Las holguras y otros factores pueden provocar el desajuste de esto valores, por lo que es necesario volver a calibrarlo cada cierto tiempo. Una mala calibración de los trims puede radicar en problemas de asimetrías en movimientos, y por tanto, resultados inesperados.

\end{itemize}

\subsubsection{Robot::Robot()}

El constructor de la clase Robot tiene como función la apertura del bus de control para los servos AX-12A, la configuración del servo PWM y la asignación de trims en el array de trims.
 


\subsubsection{void Robot::setTargetPosition(int,int,... int)}

setTargetPosition accede directamente al miembro privado targetPosition[20] para asignarle nuevos valores.

\subsubsection{void Robot::setTargetOffset(int,int,... int)}

setTargetOffset varía los valores del miembro privado targetPosition[20] para sumarles un valor. La función permite variar una posición con un giro determinado sin necesidad de conocer la posición actual de la articulación.


\subsubsection{void Robot::updateCurrentPosition()}

Esta función tiene un funcionamiento sencillo, se ocupa de volcar los datos de la posición objetivo en la posición actual. Es la forma que tiene el robot de actualizar su posición actual tras un movimiento. 

\subsubsection{void Robot::move(float)} 

La función move es la mas importante de todas, ya que es la función que se encarga de mover las articulaciones. A esta función se le pasa un valor de tiempo expresado en segundos, y tal y como se comentó al principio de este apartado, será el tiempo en el que los servos pasarán de la posición actual (currentPosition[20]) a la posición final (targetPosition[20]).

\medskip
Para ello, la función calcula la amplitud del movimiento y asigna una velocidad independiente para ese servo. Gracias a esto, todos los servos empiezan y terminan de moverse al mismo tiempo y permiten un control mas sencillo de las inercias entre movimientos consecutivos.

\subsection{Funciones de movimientos combinados TODo } 

Llegado este punto se ha abordado como mover un servo y como mover los 20 servos de forma coordinada. En este apartado se presentan algunas funciones intermedias entre lo comentado y movimientos de alto nivel, como puede ser el desplazamiento bípedo.

\medskip
Para facilitar la programación de movimientos mas complejos se han programado una seríe de utilidades que permiten mover los servos en pequeños grupos que desempeñan una funcion común. Estas funciones modifican los valores del array de posiciones finales, targetPosition[20], lo que quiere decir que para efectuar el movimiento será necesario realizar una llamada a la funcion move(float). Por tanto, es posible la utilización de varias funciones en un mismo movimiento, dando la posibilidad de sumar sus modificaciones y superponer su utilidades. 

\subsubsection{void movHead(int)}

movHead es una función que permite mover el servo PWM de la cabeza del robot. Sirve para mover la cámara independientemente de la posición instantanea del robot.


% Dibujos y otras movidas
\subsubsection{void movVertical(int,int) TODO}
Meter fotos del robot con una pierna levantada
\subsubsection{void movLateral(int,int) TODO}
\subsubsection{void movFrontal(int,int) TODO}

\subsection{Creación de movimientos completos TODO}

Encontrándonos en este punto, la programación de desplazamientos, giros y otros movimientos complejos, se ha realizado mediante la combinación de las funciones anteriormente descritas. A cada movimiento se le asignará un valor hexadecimal en forma de caracter, de forma que los caracteres comunicados a la OpenCM sirvan como identificador de el movimiento que el controlador de visión está ordenando.

\medskip Se ha creado la función void controller(char), dentro de la clase Robot, con el objetivo de indexar todos los movimientos que realizará Raider. En el cuadro \ref{movimientos} se presenta una tabla con los movimientos programados y su comando asignado.

\begin{table}[H]
\centering
\begin{tabular}{p{1.5cm} p{2cm} p{8cm}}
\hline
Comando & Función & Descripción \\
\hline \hline
\centering W & walk(3) & Caminar 3 pasos cortos\\ \hline
\centering A & turnL() & Rotación a la izquierda  \\ \hline
\centering D & turnR() & Rotación a la derecha  \\ \hline
\centering S & run(3) & Caminar 3 pasos largos y rápidos  \\ \hline
\centering Q & stepL() & Paso lateral a la izquierda  \\ \hline
\centering E & stepR() & Paso lateral a la derecha  \\ \hline
\centering K & kick() & Patada (para golpear una pelota)  \\ \hline
\centering Y & yes() & Movimiento intermitente de la cabeza  \\ \hline
\centering G & getUp() & Levantamiento desde una caída frontal  \\ \hline
\centering R & roll() & Rodar, se utiliza cuando el robot cae de espaldas  \\ \hline
\centering H & hello() & Saludo  \\ \hline
\centering q & miniTurnL() & Giro leve hacia la izquierda  \\ \hline
\centering e & miniTurnR() & Giro leve hacia la derecha  \\ \hline
\centering Z & punchL() & Puñetazo con el brazo izquierdo  \\ \hline
\centering B & punchR() & Puñetazo con el brazo derecho  \\ \hline
\centering C & crab() & Ataque de sumo con dos brazos  \\ \hline
\centering V & miniPunchR() & Puñetazo leve derecho  \\ \hline
\centering X & miniPunchL() & Puñetazo leve izquierdo  \\ \hline
\centering w & defense() & Posición defensiva  \\ \hline
\centering a & lookL() & Mirar hacia la izquierda  \\ \hline
\centering d & lookR() & Mirar hacia la derecha  \\ \hline
\centering L & look() & Mirar de frente  \\ \hline
\centering l & lookUp() & Mirar hacia arriba  \\ \hline
\centering f & endLookUp() & Volver a la posición de reposo tras lookUp()  \\ \hline


\end{tabular}
\caption{Movimientos programados}
\label{movimientos}
\end{table}

\section{Comunicación serie TODO}

En la sección anterior hemos completado la programación de movimientos sobre la placa OpenCM, sin embargo, el control principal del robot se realiza desde la BeagleBone. En este apartado se comunicará la BeagleBone con la OpenCM de forma que adopten una configuración de maestro y esclavo. La estrategia consistirá en el envío de comandos hexadecimales desde la BeagleBone a la OpenCM. Cada comando servirá de identificador para un movimiento completo. Los comandos serán los descritos en el cuadro \ref{movimientos}.


\subsection{Comunicación serie en OpenCM  TODO}

La OpenCM posee 3 puertos serie, de los cuales uno de ellos está reservado para el control del bus Dynamixel. En el esquema de la figura \ref{serialcm} se presenta la configuración de puertos serie de la OpenCM.

\begin{figure}[H]
\centering
\includegraphics[width=0.6\textwidth]{figuras/serialcm}   
\caption{Esquema de puertos serie en una OpenCM 9.04}
\label{Serialcm}
\end{figure}

Para la programación de la comunicación serie en la placa OpenCM se ha utilizado la biblioteca HardwareSerial.h, contenida en CM9 IDE. La documentación de la biblioteca está disponible en (  TODO), sin embargo, a continuación se listan las funciones que se han utilizado junto a una breve explicación de su funcionamiento.
 ( TODO )
% todo 
\subsubsection{void HardwareSerial::begin(unsigned int baud)}

Esta función habilita los pines como puerto serie. Como parámetro se le pasará la velocidad en baudios, que deberá coincidir con la del controlador maestro. En este caso, se ha configurado el puerto 3 con una velocidad de 9600 baudios

\subsubsection{unsigned int HardwareSerial::available()}

El objetivo de esta función es consultar si existe algún mensaje en el buffer de lectura. En caso afirmativo, podremos proceder a leer el mensaje.

\subsubsection{unsigned char HardwareSerial::read()}

La lectura de mensajes nos devolverá un valor hexadecimal. En nuestro caso, será el emitido por la BeagleBone Black y corresponderá a la ejecución de un movimiento.

\subsubsection{void HardwareSerial::flush()}

Con esta función vaciaremos el buffer de entrada. Se ejecutará cada vez que leamos un comando.
 
\subsection{Comunicación serie en BeagleBone}

Para poner en amrcha la comunicación serie en la BeagleBone se ha utilizado como base la librería open-source Serialib ( TODO referencia gorda). Esta librería nos permite administrar un puerto serie, y está preparada para funcionar tanto en Windows como en Linux. 

\medskip Se han realizado algunas modificaciones leves para ajustar su funcionamiento al requerido. Los métodos que se han utilizado ( TODO pueden encontrarse en el repo ) se detallan a continuación.

\subsubsection{open TODO nombre }

Esta función abrirá el puerto serie. En el primer parámetro se le pasará la cadena "/dev/ttyO2", es decir, la dirección de nuestro puerto serie. Como segundo parámetro se le pasará la velocidad del puerto, que coincidiendo con la de la OpenCM será de 9600 baudios.

\subsubsection{writechar TODO nombre }

Para mandar los comandos utilizaremos esta función. Ya que el objeto de la clase conserva las carácterísticas del puerto serie, solo será necesario pasarle el valor hexadecimal que queramos transmitir al controlador de locomoción.

\subsection{Comunicación con módulo Bluetooth TODO}

Adicionalmente, se ha incluido la posibilidad de utilizar un control auxiliar por Bluetooth desde un dispositivo externo. Para ello se ha conectado un modulo Bluetooth (figura \ref{bluetooth}) TODO directamente a la OpenCM. La función de esta otra vía de control no es otra que la realización de pruebas experimentales controladas, ya que nos permite modificar el comportamiento del robot en los momentos en los que sea necesario. Por supuesto, de cara a su funcionamiento autónomo, el módulo Bluetooth se inutilizará. Sin embargo, será necesario dejar preparada su conexión y programación. ( TODO foto de mexico )

Se ha utilizado un módulo Bluetooth hc05 conectado al puerto 3 del controlador de locomoción. Con esto, podremos mandar mensajes desde un teléfono móvil, un ordenador portátil o cualquier otro dispositivo que soporte conexión Bluetooth. Para utilizar el control del robot por Bluetooth se sustituirá el puerto de lectura de la OpenCM reservado al controlador de visión (el puerto 2) por el puerto 3.

\section{Programación de sensores TODO} 

En esta sección se detallará la programación que se ha aplicado a los diferentes sensores que se han montado en Raider.

\subsection{Infrarrojos TODO}

Para controlar los sensores infrarrojos se ha desarrollado un algoritmo ( TODO en la librería X ). Dado el carácter de este sensor, se ha realizado una programación para detectar objetos en función de dos parámetros de distancia crítica. Como puede observarse en la figura \ref{esquemarango} con estos dos parámetros (representados por la barras verticales) se han definido tres zonas.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/esquemarango}   
\caption{Rangos de detección para un sensor Sharp}
\label{esquemarango}
\end{figure}

El rango de datos que podemos extraer de la entrada analógica va de 0 a 1800mV. Teniendo esto en cuenta, se han definido experimentalmente (figura \ref{raiderrangos}) \textit{INFRARED\_LOW} en 300mV, e \textit{INFRARED\_HIGH} en 1000mV. 

\medskip [ TODO TODO TODO foto del robot pegado a la pizarra ]

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/todo}   %raiderrangos
\caption{Definición experimental de los rangos de medida}
\label{asdf}
\end{figure}

\medskip Se han desarrollado dos funciones paralelas para medir los sensores infrarrojos izquierdo y derecho de Raider: \textit{getLeftIR()} y \textit{getRightIR()}. Estas funciones devolverán un valor identificativo de la zona en la que se encuentra el obstáculo.

\subsection{IMU TODO}

La programación del sensor inercial pasa por dos fases: La extracción de datos del sensor y el procesamiento de los mismos para obtener información útil.

\medskip El MPU9150 utiliza el protocolo I2C para comunicarse con el controlador. Ofrece medidas de giroscopio, acelerómetro y magnetómetro. En este proyecto se ha utilizado solamente acelerómetro para detectar caídas, pero se han programado funciones para la lectura de todos los parámetros. Para utilizar el bus I2C de la BeagleBone Black se ha desarrollado una librería ( TODO referencia o algo ) que funciona como interfaz de la librería nativa \textit{i2c-dev}.

Con esta librería se puede leer y escribir en la tabla de registros de un sensor de forma sencilla. Los métodos de esta función son los siguientes:



\subsection{Brújula TODO} 

Calibración

\section{Algoritmos de visión TODO} 
\subsection{Análisis de trayectorias en navegación TODO} 
\subsection{Búsqueda de lineas TODO}
\subsection{Lectura de códigos QR TODO} 
 






















