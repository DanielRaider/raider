%chapter introduce un nuevo capítulo
\chapter{Aplicaciones}\label{chapteraplicaciones}

Llegamos a este capítulo, el estado del proyecto es el siguiente. Se ha desarrollado un robot completo tanto a nivel de hardware como a nivel de software. Así mismo, también se han creado herramientas para que el robot pueda interactuar con el entorno de forma controlada. Con los recursos que se han generado se preparará el robot para participar en dos eventos: La exhibición de futbol robótico Spain Experience, y la competición CEABOT 2014

\section{Spain Experience}

Spain Experience es un evento organizado por la Liga de Futbol Profesional en el que se unen actividades de sectores tecnológicos, empresariales y agroalimentarios. Con motivo de su celebración en México, el Centro de Investigación y de Estudios Avanzados (Cinvestav) \cite{webcinvestav} invitó a miembros del Robotics Lab y de AsRob a participar en un partido de futbol robótico inspirado en la competición RoboCup. El campo, visible en la figura \ref{fotomexico} es propio de robots de mayor tamaño, lo que podría suponer una desventaja..

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{figuras/fotomexico}   
\caption{Partido de futbol robótico en México}
\label{fotomexico}
\end{figure}
\FloatBarrier

\medskip Para preparar a RAIDER para la exhibición, se optará por montar el módulo Bluetooth que se comentó en capítulos anteriores del proyecto y teleoperarlo desde un smartphone. De este modo, el robot estaría funcionando durante mas de dos horas realizando cambios de batería, aproximadamente cada 10 minutos. Esta exhibición supone un gran paso en el desarrollo del robot, ya que es una forma excelente de someter a estress sus componentes y de operar en un escenario externo al laboratorio.

\section{CEABOT 2014}

Tal y como se ha ido diciendo a lo largo del proyecto, el robot se presenta a la edición de 2014 del CEABOT. Se propuso la participación de RAIDER en tres pruebas: Navegación, visión y sumo. Estos programas pueden encontrarse en el repositorio, en la carpeta \textit{programming/src/apps/ceabot}. A continuación se detallan los algoritmos que se han diseñado para cada una de las pruebas.

\subsection{Algoritmo para la prueba de visión}

El algoritmo de la prueba de visión se basará en dos pilares: La cámara y la brújula. Con la cámara y la funcion \textit{findQR()} de \textit{raider.h} se realizará la detección de los marcadores. Por otro lado, la brújula se encargará de controlar el giro del robot para adecuarlo a las exigencias del marcador. A continuación, en la figura \ref{flujovision} se mostrará el diagrama de estados que se ha programado.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/flujovision}   
\caption{Diagrama de estados simplificado de la prueba de visión}
\label{flujovision}
\end{figure}
\FloatBarrier


\medskip El primer lugar el robot parte de un estado de inicio, en el que mantiene una posición de reposo. Seguirá en esta posición hasta que se le de una señal de inicio. La señal de inicio se ha programado en la función \textit{waitStart()} de \textit{raider.h}. Una vez se ejecuta el robot se mantendrá realizando lecturas de códigos QR. Si se pone el marcador de la figura \ref{goraider} en frente del robot (impreso en una tarjeta de papel, por ejemplo) el robot comenzará la prueba.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/goraider}   
\caption{Código QR de inicio (Texto: GoRaider)}
\label{goraider}
\end{figure}
\FloatBarrier

\medskip Una vez ha comenzado, guardará la medida que toma la brújula en la posición inicial. Ésta medida constituirá la primera referencia de la posición del robot. Tras ello, buscará el primer marcador, que por normativa se encontrará en frente de él. La búsqueda de códigos QR transcurre de la siguiente manera. El robot realizará un análisis visual, si éste falla, cambiará la altura de enfoque de la cámara y volverá a intentarlo. Como medida de seguridad, se ha programado que en el caso de que se produzcan 5 lecturas fallidas, el robot rote e intente recolocarse en su posición. 

\medskip Tras realizar una lectura positiva de un marcador, se definirá una posición objetivo, basandose en la referencia del robot en ese momento y sumandole el incremento que indique el marcador. El robot comenzará a rotar y cuando alcance la posición objetivo tomará esa posición final como la nueva referencia. Tras esto, el algoritmo volverá a intentar detectar un código QR y se cerrará el bucle.

\medskip Cabe destacar un detalle: Las posiciones objetivo se definirán con la referencia de la posición del robot y el incremento que marque el código QR. Salvo en la primera detección (en la que la referencia se toma de una medida de la brújula), las referencias se definirán como la posición objetivo de la búsqueda anterior y en ningún caso como una medida de la brujula al terminar los movimientos. De esta forma cada punto objetivo no estará sujeto a errores acumulativos, ya que su distancia respecto a la referencia inicial será siempre un múltiplo de $45º$. 

\subsection{Algoritmo para la prueba de navegación}

El algoritmo de la prueba de navegación quizás sea el mas complejo de los tres programados. En la figura \ref{flujonavegacion} se ha realizado un diagrama de estados a alto nivel del comportamiento del robot durante la prueba.

\medskip De forma similar a la prueba de visión, el robot partirá de una posición de reposo, y se mantedrá en esa posición hasta que le indiquemos que comience la prueba con el código QR de la figura \ref{goraider}. Una vez que se da la orden, el robot toma una referencia magnética de la dirección en la que deberá recorrer el campo. Tras ello, comenzará a caminar.

\medskip Se ha implementado un control de caídas continuo durante toda la prueba. Para ello se ha utilizado la función \textit{getFall}, detallada anteriormente en el capítulo anterior. Después de realizar cada movimiento, RAIDER evalúa si su posición es vertical respecto al suelo. En caso de que se detecte una caída, el robot se levantará de forma autónoma y continuará con su programación. 

\medskip Antes de dar cada paso, RAIDER analiza la trayectoria que debe seguir con la función \textit{findWay}. Esta función, como se vió en el apartado de programación, devolverá datos de la distancia que existe entre el robot y el punto de inicio de la trayectoria, y sobre el ángulo que forma el primer tramo de la trayectoria. Si el robot está lejos del punto de inicio, deberá acercarse con pasos laterales. Si el ángulo que forma el tramo es demasiado amplio, el robot rotará sobre sí mismo para orientarse. La definición de qué es ''lejano'', qué es ''amplio'', y su evaluación respecto al robot, se realizan con dos parámetros parametrizables dentro de \textit{raider.h}. Por otro lado, cuando la linea es recta el robot podrá avanzar sin problemas. Existe una condición más, si el robot avanza de forma recta tres veces seguidas, se ejecutará una rutina para controlar si el robot está orientado correctamente y está siguiendo la dirección adecuada. Cuando esto ocurre, se compara la dirección medida por la brújula en ese instante con la referencia magnética que se tomó al principio de la prueba. En caso de que esta dirección sea diferente, el robot rotará sobre sí mismo para recuperar la orientación.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/flujonavegacion}   
\caption{Diagrama de estados simplificado de la prueba de navegación}
\label{flujonavegacion}
\end{figure}
\FloatBarrier

\medskip Tras ejecutar el desplazamiento, RAIDER intenta buscar la linea blanca mediante la función \textit{findLine}. Si no hay ninguna detección volverá a buscar una trayectoria para seguir avanzando, sin embargo, si encuentra la linea blanca, se realizará una rutina especial. Primeramente cabe explicar qué significa esto: Que encuentre la linea blanca significa que ha llegado al ecuador de la prueba y que deberá cruzarla para posteriormente realizar el camino de vuelta. Por tanto, si el resultado de buscar la linea es positivo, la función \textit{findLine} nos devolverá dos valores. Por una parte tendremos el valor de la distancia del robot al centro de la recta, que nos dará una idea aproximada de cuantos pasos necesitará realizar para cruzarla. Por otra parte, tenedremos el valor de el angulo que forma el robot respecto a la linea. Nos interesa que RAIDER se sitúe perpendicularmente a la linea, por tanto, si este ángulo está lejos de esa posición será necesario que el robot se oriente de forma adecuada. Para definir si el robot está en un angulo lo suficientemente cerca de la perpendicularidad de la linea o debe rotarse un poco, se ha definido un valor parametrizable en la función \textit{raider.h}.

\medskip Ya colocado correctamente junto a la linea, RAIDER caminará hacia el otro lado. Al llegar al otro lado se habrá superado la primera mitad de la prueba. Antes de emprender la vuelta, se deberá variar la referencia magnética que se tomó con la bújula al principio de la prueba. A esta referencia se le sumarán $180º$, de forma que ahora el robot tratará de avanzar en esa dirección. Cuando se detecta la linea se activa un flag que indicará al robot que no debe volver a buscar lineas, sino que hasta el final de la prueba solo debe avanzar. De esta forma, RAIDER completará la segunda parte del recorrido.

\subsection{Algoritmo para la prueba de sumo}

En la prueba de sumo no se ha utilizado la cámara del robot, ya que no se ha considerado necesario. Esta prueba se basará en los sensores infrarrojos de los brazos de RAIDER. Esto se debe a que en esta prueba prima la programación de movimientos efectivos por encima de la sensorización. La programación de la prueba de sumo se ha basado en el diagrama de estados de la figura \ref{flujosumo}. 

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/flujosumo}   
\caption{Diagrama de estados simplificado de la prueba de sumo}
\label{flujosumo}
\end{figure}
\FloatBarrier

\medskip Como en el resto de programas, el robot permanece en reposo hasta que se le da una señal de inicio. LA diference es que en este caso no se utilizará la función \textit{waitStart}, sino que se activará directamente desde el interruptor de seguridad. Este interruptor, como se aprecia en la figura \ref{interruptor}, se encuentra en una zona accesible en la espalda del robot y se utiliza para cortar virtualmente la comunicación entre el controlador principal y el controlador de locomoción de este modo. Cuando el interruptor está encendido, RAIDER permanece inmovil en una posición neutra. También, gracias a este interruptor se pueden realizar paradas de emergencia durante las pruebas.

TODO

\begin{figure}[h]
\centering
%\includegraphics[width=1\textwidth]{figuras/interruptor}   
\caption{Interruptor de emergencia}
\label{interruptor}
\end{figure}
\FloatBarrier

\medskip Cuando el interruptor se apaga, RAIDER realiza una pausa reglamentaria de 5 segundos. Tras ello comienza la prueba. Primero realizará una medición con los dos sensores infrarrojos apuntando hacia delante. Si alguno de estos dos sensores detecta un objeto en la zona crítica (representada en la figura \ref{esquemarango}) RAIDER lanzará un puñetazo con el brazo izquierdo o el brazo derecho, en función de qué medición es mayor. Si encuentra un objeto en la zona de detección lejana intentará acercarse. En este caso existirán dos posibilidades: Que ambos sensores hagan una detección lejana o que solo lo haga uno de ellos. Si ambos sensores miden la detección lejana, el robot avanzará hacia delante. Por otra parte, si solo realiza la detección uno de ellos, RAIDER rotará hacia el lado del sensor que haya tomado la medida. De este modo, se orientará hacia su objetivo.

\medskip También cabe la posibilidad de que ninguno de los dos sensores detecte nada. En este caso, RAIDER girará sobre su cintura para mirar hacia un lado. Cada vez que se llame a esta función RAIDER mirará a un lado diferente al de la última mirada, de esta forma se moverá a izquierda y a derecha intermitentemente. En el caso de que despues de uno de estos giros detecte un objeto en la posición crítica, RAIDER lanzara un ataque ligero con el brazo mas cercano al objetivo. Estos golpes son mas débiles que los que se realizan en la posición de defensa porque en este momento el robot se encuentra en una posición inestable y podría caerse.

\medskip Paralelamente, existe un control de verticalidad. Con la función \textit{getFall} se analiza si el robot sigue de pie despues de cada movimiento. En el caso de que se haya caída, realizará la rutina de reincorporarse. Esto es muy importante en la prueba de sumo, ya que puede suponer una perdida de puntos que el robot caiga al atacar a su oponente y no se levante.



