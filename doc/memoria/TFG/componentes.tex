%chapter introduce un nuevo capítulo
\chapter{Elección de componentes}\label{chaptercomponentes}

Como punto de partida, se han seleccionado una serie de componentes adecuados para dotar al robot con las capacidades necesarias para cumplir los objetivos. Dado que el sistema se va a rediseñar completamente, se elegirán los componentes que mejor se adapten a nuestras necesidades sin tener que ceñirse a limitaciones de compatibilidad.

\section{Plataforma robótica}

El primer paso para la realización de este proyecto fue el estudio y selección de las plataformas robóticas que se encuentran en el mercado actualmente. Dado que el objetivo es encontrar un robot humanoide sobre el que se pueda implantar un sistema de visión, es necesario analizar diversos aspectos; algunos mecánicos como el numero y fuerza de los actuadores, y otros electrónicos como la capacidad de procesamiento y velocidad del controlador. Sin embargo, dado que este proyecto es autofinanciado en su mayor medida, el factor económico también es un limitante destacable. Buscamos una plataforma que cumpla los siguientes requisitos:

\begin{itemize}
\item{Programable en C/C++.} 

Se requiere que sea programable en C/C++ y que además no dependa de una IDE concreta.

\item{Posibilidad de conectarle una cámara.}

Se necesita que permita conectarle una cámara y realizar programas con OpenCV.

\item{Expandible con sensores y actuadores.}

El sistema debe permitir la adición de nuevos sensores y actuadores, sin verse limitado por hardware o software.

\medskip \item{Servos de al menos 12kg/cm.}

Ya que se van a incluir nuevas partes, es absolutamente necesario que los servos puedan soportar carga adicional colocada en el robot.

\item{Chasis reconfigurable.}

Aunque no es tan importante como el resto, es posible que el robot requiera modificaciones, por lo que una base reconfigurable y versátil será apreciada.

\end{itemize}

En el siguiente apartado se presenta un estudio las principales opciones.



\bigskip \subsubsection{Comparativa y elección final}

Realizando un primer análisis, ninguno de los robots candidatos cumple los requísitos. Todos ellos obligan a utilizar entornos de desarrollo y lenguajes propios para su programación. El Robonova y el Robovie tienen unos servos demasiado débiles, lo que dificultaría mucho añadir más peso al robot. Entre el Kondo y el Bioloid, se ha elegido el Bioloid por tres razones: Es más fácil de modificar, el kit contiene más servos  y es más barato. También, previendo las modificaciones futuras, se contempló la idea de comprar únicamente los servos Dynamixel que usa el Bioloid por separado. Sin embargo, resultó más económico adquirir el kit completo de Bioloid Comprehensive.


\section{Modificaciones estructurales}

El Bioloid Comprehensive es un buen punto de partida, sin embargo tiene algunos puntos débiles que conviene revisar. Además, para poder implantar en el robot los dispositivos que requiere este proyecto se necesitarán mejorar las capacidades de la plataforma.


\subsection{Cabeza móvil}

Un requisito importante del proyecto es permitir que la cámara que vamos a montar pueda moverse con libertad para enfocar a diferentes zonas de su entorno. Dado que en CEABOT la mayoría de los datos  que aporta el entorno están situados en el suelo, necesitamos que la cámara al menos pueda dirigirse hacia el frente y hacia el suelo. Esto lo conseguiremos con la adición de un microservo PWM y una plataforma articulada para la cabeza. Dadas las características de este movimiento, no necesitamos un servo con grandes capacidades, ya que su rango de acción estará muy limitado y su efecto será despreciable en el reparto de pesos del robot.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/microservo}   
\caption{Microservo PWM.}
\label{microservo}
\end{figure}
\FloatBarrier


Se ha elegido un microservo PWM por su bajo tamaño y peso, su bajo precio y su sencillez a la hora de montarlo y programarlo. El principio de funcionamiento de un servo PWM es muy simple. De las tres patillas de su conector, dos son de alimentación y la tercera se encarga de recibir una señal PWM que, variando la amplitud de su pulso, ordena al servo a moverse a una posición fijada.

Particularmente, se ha escogido un servo Tower Pro MG90s como el de la figura \ref{microservo}, cuyas especificaciones presentan un torque de 2.4=kg/cm, y una transmisión metálica soportada por rodamientos. Este último dato es muy importande si tenemos en cuenta que el sistema de cabeza móvil se situará en una zona extrema del robot, y que un golpe provocado por una caida forzará de forma directa el eje del servo de la articulación. Este servo proporcionará a la cabeza la robustez necesaria para salir indemne en este tipo de accidentes. Accidentes que por otra parte son muy comunes teniendo en cuenta que el robot estará destinado a la realización de pruebas de competición.

\subsection{Cintura móvil}\label{subsubcintura}

Otra de las modificaciones básicas a realizar sobre la plataforma robótica, ha sido la inclusión de un servo adicional Dynamixel AX-12A para articular la cintura. A parte de la mejora de capacidades que se produce en los movimientos del robot, servirá para girar la dirección de la cámara radialmente. Podría decirse que entre el servo de la cabeza y el de la cintura, se ha creado un sistema distribuido de pan-tilt que permitirá mover la cámara en todas las direcciones manteniendo fija la base del robot, es decir, sus piernas.

\section{Sensorización}

El funcionamiento del robot y su control va a estar basado principalmente en la cámara y los algoritmos de visión que se programarán. No obstante, la cámara consume muchos recursos del procesador y existen alguna tareas sencillas que es más fácil programar con sensores más simples. A continuación se muestra un estudio de sensores que pueden ser útiles en el proyecto.

\subsection{Sensores de distancia}

Existen diferentes tipo de sensores de distancia. El propósito de estos sensores no es otro que la medición de longitudes utilizando diferentes principios físicos. Se ha planteado el uso de sensores infrarrojos y/o de sensores de ultrasonidos.

\subsubsection{Sensores de luz infrarroja}

Los sensores infrarrojos, como el que aparece en al figura \ref{sensorir} basan su funcionamiento en la reflexión de luz infrarroja sobre superficies. El sensor está formado por dos LEDs infrarrojos, uno emisor y otro receptor. El emisor emite de forma continua una luz infrarroja dirigida hacia un punto fijo. Si en ese punto fijo se encuentra un objeto físico, la luz se reflejará y será captada por el diodo receptor. La salida de estos sensores se mide mediante la diferencia de potencial que se produce en el diodo receptor. Se ha estudiado la inclusión en el proyecto de sensores infrarrojos Sharp, especialmente de su modelo GP2Y0A21YK, que tiene un rango de operación de entre 4 y 150cm.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/sharp}   
\caption{Sensor infrarrojo.}
\label{sensorir}
\end{figure}
\FloatBarrier

\subsubsection{Sensores de ultrasonidos}

Los sensores de ultrasonidos detectan distancias basandose en el tiempo en el que un sonido de alta frecuencia recorre el espacio. Normalmente, los sensores de ultrasonidos tienen dos focos, uno emisor y otro receptor. Una de las diferencias de este tipo de sensores con los sensores infrarrojos es que mientras los sensores infrarrojos toman medidas de un punto, el rango de operación de los sensores de ultrasonidos se abre en un como de 60º de amplitud desde su emisor. Se ha analizado el sensor de ultrasonidos HC-SR04 como posible candidato para formar parte del robot por su fácil accesibilidad. Otro punto importante es que en estos sensores la salida es proporcional a la distancia medida, es decir, se adecúa a una recta. Es por esto por lo que podremos realizar medidas reales directamente midiendo la salida del sensor.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/sensorus}   
\caption{Sensor de ultrasonidos}
\label{sensorus}
\end{figure}
\FloatBarrier

\subsubsection{Experimentos de medida}

Para poner en práctica y obeservar las diferencias teóricas que existen entre el funcionamiento de ambos sensores, se ha realizado un pequeño experimento en el que se han realizado medidas de longitud entre el sensor y un obstáculo. Para ello, se han analizado tres configuraciones posibles. En cada imágen, se ha marcado en azul el rango de acción del sensor. La linea roja representa la distancia que medirá el sensor en cada situación.

\medskip En el experimento de la figura \ref{experimento1}, se ha colocado un obstáculo como los que se utilizan en la prueba de navegación de CEABOT en posición frontal y recta. Puede observarse que en esta situación ambos sensores medirían de forma similar la distancia entre el sensor y el obstáculo.

\begin{figure}[h]
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{0.5\textwidth} >{\arraybackslash}m{0.5\textwidth}}
\includegraphics[width=0.45\textwidth]{figuras/expir1} & \includegraphics[width=0.45\textwidth]{figuras/expus1}  \\
\end{tabular}
\caption{Primer experimento.}
\label{experimento1}
\end{figure} 

En el experimento de la figura \ref{experimento2} se ha desplazado el objeto ligeramente hacia la derecha. Puede observarse cómo el rango de acción del sensor infrarrojo, al tener una forma lineal, no detecta el obstáculo. Mientras tanto, el sensor de ultrasonidos es capaz de detectarlo, ya que en esa posición sigue estando dentro de su rango de acción. 

\begin{figure}[h]
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{0.5\textwidth} >{\arraybackslash}m{0.5\textwidth}}
\includegraphics[width=0.45\textwidth]{figuras/expir2} & \includegraphics[width=0.45\textwidth]{figuras/expus2}  \\
\end{tabular}
\caption{Segundo experimento.}
\label{experimento2}
\end{figure} 
\FloatBarrier

Por último, el experimento de la figura \ref{experimento3} muestra el comportamiento de ambos sensores al enfrentarse a una superficie oblicua. Tal y como puede observarse en la imagen, el sensor infrarrojo realiza una medida puntual a la zona del obstáculo que se interpone en su rango de acción. Por otra parte, el sensor de ultrasonidos nos devuelve la distancia del punto del objeto que, encontrándose dentro de su rango, constituye la distancia mínia entre ambos.

\begin{figure}[h]
\centering
\begin{tabular}{ >{\centering\arraybackslash}m{0.5\textwidth} >{\arraybackslash}m{0.5\textwidth}}
\includegraphics[width=0.45\textwidth]{figuras/expir3} & \includegraphics[width=0.45\textwidth]{figuras/expus3}  \\
\end{tabular}
\caption{Tercer experimento.}
\label{experimento3}
\end{figure} 

De este experimento pueden sacarse varias conclusiones. La primera de ellas es que no existe un sensor mejor que el otro, cada uno destaca en una funcionalidad. Un sensor infrarrojo nos dará una mejor precisión a la hora de realizar medidas de distancia en un punto concreto, sin embargo, su rango de acción es limitado y será importante controlar donde está apuntando exactamente en cada momento. El sensor de ultrasonidos por su parte, detectará un obstáculo con mayor probabilidad, pero siempre existirá un incertidumbre respecto al posicionamiento exacto del obstáculo que estamos midiendo. De esta forma, un sensor infrarrojo será útil cuando necesitemos precisión en la posición del objeto y por este motivo, será el seleccionado para montarse en el robot. De todos modos, no se descarta la idea de montar también sensores de ultrasonidos en un futuro.

\subsection{Sensores inerciales}

El control del equilibrio del robot es muy importante en configuraciones bípedas, ya que estos robots son conocidos por su facilidad para tropezar y caer al suelo. Con el objetivo de analizar la posición del robot respecto al suelo se ha requerido la inclusión de diferentes sensores inerciales.

\subsubsection{Acelerómetro y giroscopio}

En el mercado existen varios modelos económicos. En este proyecto se ha utilizado el sensor MPU9150 que aparece enla figura \ref{imu}. Se trata de un sensor inercial compuesto de acelerómetro de 3 ejes, giroscopio de 3 ejes y brújula de 3 ejes. Este sensor combina dos sensores, un MPU6050 (incluye el acelerometro y el giroscopio) y un AK8975 (incluye la brújula). Sin embargo, en la práctica se observó que la brújula incluida en el sensor era muy propensa a sufrir interferencias, por lo que se decidió montar una brújula adicional que no tuviese estos problemas.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/imu}   
\caption{Sensor inercial MPU9150.}
\label{imu}
\end{figure}

\subsubsection{Brújula magnética}

La inclusión de una brújula es indispensable cuando de requiere conocer la dirección en la que se desplaza un robot. En este proyecto se montará un brújula para evaluar si el desplazamiento del robot se produce de forma recta y efectuar los redireccionamientos necesarios. Existen diferentes modelos de brújulas digitales en el mercado. Todas ellas, basan su funcionamiento en la detección y medición de campos magnéticos. Para lograr conocer la orientación del robot, la brújula deberá apoyarse en su posición respecto a la del campo magnético terrestre. El gran problema de estos dispositivos es su facilidad para modificar sus medidas cuando existe un campo magnético fuerte en su entorno. Esta interferencias pueden ser causadas por aparatos electrónicos, estructuras metálicas o incluso por los propios componentes del robot.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/compass}   
\caption{Brújula magnética CMPS03.}
\label{compass}
\end{figure}
\FloatBarrier

\medskip Para este proyecto se ha utilizado una brújula CMPS03 como la de la figura \ref{compass}. El motivo de haber seleccionado este modelo frente a otros más comúnes, como por ejemplo la HMC5883L, se debe a que ya ha sido utilizada en anteriores proyectos robóticos en la asociación con muy buenos resultados. Esto se debe en parte a que la placa del sensor incluye un PIC que se encarga de calibrar y comunicar los datos medidos, de forma que no será necesario que el controlador del robot realice estos cálculos y podrá utilizar directamente la medida extraída.

\subsection{Cámara}

La elección de la cámara ha sido condicionada principalmente por su compatibilidad con el driver de Linux v4l2. Existe una amplia variedad de cámaras válidas en el mercado. Dado el carácter de este proyecto, se ha optado por utilizar una webcam, ya que son más accesibles que las cámaras avanzadas de investigación y los algoritmos de visión que serán programados no requieren imágenes de alta calidad.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/camara}   
\caption{Microsoft LifeCam Cinema.}
\label{camara}
\end{figure}
\FloatBarrier


\medskip El modelo selecionado ha sido una Microsoft LifeCam Cinema como la que aparece en la figura \ref{camara}. Entre sus carácterísticas destacan su posibilidad de grabar video en 720p HD, enfoque automático y la regulación de brillos en tiempo real. Adicionalmente, se trata de una cámara de fácil desmontaje y dimensiones contenidas, por lo que será sencillo integrarla en el robot.

\medskip Cabe remarcar que antes de utilizar esta cámara se realizaron pruebas con una Hama Pocket, pero dada su baja calidad de construcción presentó diversos problemas de fiabilidad y fue despreciada en favor de la Microsoft. 

\section{Elección del controlador}

Llegamos a un punto crítico del proyecto, y es la elección de un controlador para nuestro sistema. La controlador CM-5 contenida en el kit original de Bioloid Comprehensive se encuentra muy lejos de poder soportar el conjunto de nuevos dispositivos que se usarán en el proyecto. Necesitaremos reemplazarla por un sistema más complejo que nos permita conectar y programar los sensores seleccionados, programar algoritmos de visión y comunicarse con los servos Dynamixel.

\medskip Para solucionar esto se decide colocar un SBC (Single Board Computer, ordenador de placa única), que dadas sus capacidades de procesamiento se utilizará como controlador principal. Así mismo, será el encargado de realizar el procesamiento de imágenes. Junto al SBC, se conectará un controlador más sencillo basado en un microcontrolador para controlar los Dynamixel AX-12A por separado. 

\medskip De esta forma, el controlador del robot estará formado por dos elementos, el SBC que se encargará del procesamiento de imágenenes y sensores, y un microcontrolador se encargará de la locomoción del robot.

\subsection{Controlador de locomoción}

El controlador de locomoción debe encargarse de mover los 20 servos del robot y de comunicarse con el controlador de visión para recibir instrucciones. A continuación se realiza un estudio de posibles placas que podrían utilizarse.

\subsubsection{Arduino}

Las placas Arduino se han hecho famosas por su fácil programación y puesta en marcha. Dada su popularidad, existe una gran comunidad de usuarios que generan documentación de forma constante. Con una placa Arduino disponemos de una amplia colección de bibliotecas para interactuar con sensores y actuadores. Sin embargo, estas placas por si solas no soportan la comunicación con los servos Dynamixel. Por esta razón, se ha desestimado su uso en el proyecto.  

\subsubsection{Arbotix}

La placa Arbotix, mostrada en la figura \ref{arbotix} está basada, al igual que las placas Arduino, en un microcontrolador AVR. No obstante, esta placa de desarrollo está orientada principalmente a la construcción de pequeños robots, por lo que posee capacidades mejores que las de las placas Arduino. Entre sus especificaciones destacan: 2 puertos serie (uno de ellos reservado para el bus Dynamixel), 32 pines de entrada/salida, 8 entradas analógicas, 2 drivers de 1A para motores de continua y zócalos para la conexión de módulos XBEE. 

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/arbotix}   
\caption{Placa Arbotix.}
\label{arbotix}
\end{figure}
\FloatBarrier


El problema de estas placas es que no existe un distribuidor que las venda en Europa. Eso no solo significa que sean difíciles de conseguir, sino también que no tienen demasiados usuarios, y por tanto la documentación es escasa y heterogenea.

\subsubsection{Serie OpenCM}

Recientemente la empresa Robotis ha sacado a la venta una nueva linea de placas de desarrollo, las placas OpenCM. En la figura \ref{cm900} se muestra una CM900. Estas placas de desarrollo están basadas en las placas Arduino, copiando sus funcionalidades y añadiendo al sistema la posibilidad de comunicarse con actuadores Dynamixel. Su entorno de programación está basado en Arduino IDE y continene bibliotecas similares a las de Arduino para la comunicación con sensores y actuadores. Su alta compatibilidad con Arduino proporciona al usuario una mayor facilidad a la hora de buscar documentación sobre cómo utilizar la placa.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/cm900}   
\caption{Placa CM900.}
\label{cm900}
\end{figure}
\FloatBarrier

Si bien es cierto, es necesario comentar que la primera edición, la CM900, presentó problemas en su diseño que la conviertieron en una placa muy poco fiable y propensa a deteriorarse prematuramente. En este proyecto se utilizará la OpenCM9.04, sucesora de la CM900, con similares capacidades y tamaño reducido. Entre sus especificaciones destacan: Un microcontrolador ARM Cortex-M3, 26 pines de entrada/salida, 10 entradas analogicas de 12 bits y 3 puertos serie (uno de ellos reservado para el bus Dynamixel).

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{figuras/opencm}   
\caption{Placa OpenCM9.04.}
\label{opencm}
\end{figure}
\FloatBarrier

\subsection{Controlador de visión}

Como controlador principal, se utilizará un SBC (Single Board Computer). Por tamaño y capacidades existen dos alternativas directas: La Raspberry Pi B y la BeagleBone Black.

\subsubsection{Raspberry Pi}

La Raspberry Pi es un ordenador completo del tamaño de una tarjeta de crédito, dirigida a formar parte de proyectos de electrónica, informatica y robótica. Dado su bajo coste y fácil adquisición, la Raspberry Pi cuenta con una comunidad de usuarios muy extensa repartida a lo largo del mundo. En internet existen colecciones de tutoriales educativos para formar al usuario y dar soporte a sus proyectos. En el cuadro \ref{raspec} se describen las especificaciones técnicas de la placa.

\begin{table}[h]
\centering
\begin{tabular}{ >{\arraybackslash}m{4.2cm} >{\arraybackslash}m{5.8cm}}
\hline
Especificaciones Raspberry PI modelo B \\
\hline \hline
\medskip CPU \medskip & ARM 1176JZF\-S 700 MHz  \\ \hline
\medskip Memoria (SDRAM) \medskip & 512 MB (compartidos con la GPU)\\ \hline
\medskip Puertos USB 2.0 \medskip & 2 (vía hub USB integrado) \\ \hline
\medskip Almacenamiento integrado \medskip & SD / MMC / ranura para SDIO \\ \hline
\medskip Periféricos de bajo nivel \medskip & 8 x GPIO, SPI, I2C, UART \\ \hline
\medskip Consumo energético \medskip & 700 mA (3.5 W) \\ \hline
\medskip Fuente de alimentación \medskip & 5 V vía Micro USB o GPIO header  \\ \hline
\medskip Dimensiones: \medskip & 85.60mm $\times$ 53.98mm\\ \hline
\medskip Sistemas operativos soportados: \medskip & \medskip GNU/Linux: Debian (Raspbian), Fedora (Pidora), Arch Linux (Arch Linux ARM), Slackware Linux. RISC OS2 \medskip \\ \hline
\end{tabular}
\caption{Especificaciones Raspberry Pi B.}
\label{raspec}
\end{table}
\FloatBarrier


En el caso que nos ocupa, sería una perfecta candidata a ocuparse del procesamiento de imágenes del robot, sin embargo hay algunos detalles que es importante conocer. El primer problema de la Raspberry Pi es que la lógica de sus pines trabaja a 5V, mientras que la placa que hemos seleccionado para la parte de locomoción, la OpenCM, funciona a 3.3V. Esto significa que para comunicar ambas placas sería necesario incluir un convertidor lógico en el sistema. Por otra parte, sus GPIOs tienen un funcionamiento puramente binario, sin entradas analógicas ni generación de señales PWM. Por último, como puede observarse en la figura \ref{raspberry} aunque tiene un tamaño razonable, la placa cuenta con varios conectores de video, audio, conexion en red... etc que aunque podrían resultar útiles en otro tipo de proyectos, en nuestro caso estorbarán a la hora de integrar el dispositivo en la espalda del robot.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/raspberry}   
\caption{SBC Raspberry B.}
\label{raspberry}
\end{figure}
\FloatBarrier

\subsubsection{BeagleBone Black}

La BeagleBone Black de Texas Instruments, fotografiada en la figura \ref{beaglebone}, no es tan popular como la Raspberry Pi, sin embargo posee algunas características muy interesantes.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/bbbboard}   
\caption{SBC BeagleBone Black.}
\label{beaglebone}
\end{figure}
\FloatBarrier


\medskip Como puede observarse en el cuadro \ref{blaspec}, sus características son ligeramente superiores a las de la Raspberry. Principalmente, el hecho de que tenga tal variedad de pines la hace muy adecuada para usarse como controlador principal de un robot. La BeagleBone Black actualmente no cuenta con una comunidad tan extensa como la Raspberry Pi, pero cada vez se ve más en proyectos. El problema fundamental de la BeagleBone Black es la falta de bibliotecas en C/C++ que permitan programar sus periféricos de bajo nivel. Esto significa que en el caso de utilizar esta placa, se deberán programar bibliotecas propias para estos propósitos. 

\begin{table}[h]
\centering
\begin{tabular}{ >{\arraybackslash}m{4.2cm} >{\arraybackslash}m{5.8cm}}
\hline
Especificaciones BBB \\
\hline \hline
\medskip CPU \medskip  &  AM335x 1GHz ARM Cortex-A8  \\ \hline
\medskip Memoria (SDRAM) \medskip  & 512 MiB \\ \hline
\medskip Puertos USB 2.0 \medskip  & 1x Standard A y 1x mini B \\ \hline
\medskip Almacenamiento integrado \medskip  & 4GB 8-bit eMMC / microSD \\ \hline
\medskip Periféricos de bajo nivel \medskip  & \medskip 4xUART, 8x PWM, LCD, GPMC, MMC1, 2x SPI, 2x I2C, A/D Converter, 2x CAN bus \medskip \\ \hline
\medskip Consumo energético \medskip  & 1200 mA (6 W) \\ \hline
\medskip Fuente de alimentación \medskip  & \medskip 5 V vía Micro USB, jack de 5.5mm a 5 V o GPIO header \medskip \\ \hline
\medskip Dimensiones: \medskip & 86.40 mm $\times$ 53.30 mm \\ \hline
Sistemas operativos soportados: &  \medskip  Fedora, Android, Ubuntu, Debian, openSUSE , Ångström, FreeBSD, NetBSD, OpenBSD, QNX, MINIX 3, RISC OS, y Windows Embedded. \medskip  \\ \hline
\end{tabular}
\caption{Especificaciones BeagleBone Black.}
\label{blaspec}
\end{table}
\FloatBarrier


Por otro lado, su lógica funciona a 3.3V y es más compacta que la Raspberry Pi. Por todo lo comentado, y aunque trabajar con ella pueda resultar más tedioso que con la Raspberry Pi, se ha seleccionado la Beaglebone Black como controlador principal del robot.

\subsection{Arquitectura hardware}

Una vez se ha seleccionado todos los elementos que fomarán parte del robot, se ha diseñado el conexionado que llevarán. Tal y como se ha ido viendo a lo largo de este apartado, por un lado tendremos la OpenCM que se encargará de controlar el servo PWM y los servos Dynamixel. La BeagleBone en cambio, se encargará de recibir los datos de todos los sensores y de la cámara. Las dos placas se conectarán en serie. El diagrama de la figura \ref{dia1} representa las conexiones de todos los dispositivos, a excepción de la parte de alimentación, que se verá en la próxima sección.

\begin{figure}[h]
\centering
\includegraphics[width=1\textwidth]{figuras/dia1}   
\caption{Diagrama de conexiones.}
\label{dia1}
\end{figure}
\FloatBarrier


\section{Alimentación}

La batería contenida en el kit es una batería NiMH de 8 elementos AA Sanyo Eneloop que desarrolla 9.6V y 1900mAh. Para el consumo de este robot es una opción aceptable que proporciona cerca de 10 minutos de autonomía. No está mal si se tiene en cuenta que pruebas con el CEABOT tiene una duración máxima limitada a 5 minutos. No obstante, tiene un inconveniente, su peso y su volumen es muy alto. Al estar situada en la espalda, el centro de gravedad del robot sube en altura de forma considerable. Esto causa inestabilidades y complica bastante la programación de desplazamientos.

\subsection{Batería}

Por las razones descritas, se ha decidido buscar una alternativa. Los requísitos para seleccionar una batería los marcan tres factores: La tensión de funcionamiento de los servos, la de las placas de control y la de los sensores. Pero dado que los servos tienen una tensión de operación en un rango de 9V a 12V, respecto al resto de elementos que serán alimentados a 5V o 3.3V, nos centraremos principalmente en encontrar una batería adecuada para los servos.

\medskip Hoy en día, las baterías NiMH están empezando a caer en desuso a favor de las baterías de litio. Se barajaron dos posibilidades.

\subsubsection{Baterías de polímero de litio}

Las baterías de polímero de litio, más conocidas como baterías LiPo, destacan por desarrollar una tasa de descarga bastante alta y por tener un tamaño y peso reducido. Dado su uso en automodelismo y aeromodelismo, son unas baterías muy comunes que en los últimos años han ido bajando su precio. Actualmente existe una gran variedad de baterías LiPo de diversos tamaños y precio asequible. Cada célula LiPo ofrece 3.7V, por lo que la elección correcta para este robot sería una batería de 3S, o lo que es lo mismo, 11,1V.

\medskip Sin embargo, las baterías LiPo tienen una desventaja importante, su fragilidad. El proceso de carga y descarga de una batería de este tipo no es un asunto trivial, una sobredescarga de la batería provoca un deterioro inmediato de la misma, calentando sus elementos e incluso pudiendo llegar a incendiarse. Es por ello que se necesita un cargador con capacidad para balancear las células, de forma que las tensiones de cada una de ellas se tengan bajo control durante el proceso.

\subsubsection{Baterías de litio fosfato de hierro}  

Las batería de litio fosfato de hierro, es decir, LiFe, son conocidas por su gran resistencia y larga vida útil. Cada célula de LiFe desarrolla 3.3V y no presenta problemas por sobredescargas. De hecho, estas baterías ni siquiera requieren de un cargador balanceador para su carga, sino que pueden cargarse sin problemas con un cargador normal. El gran problema de estas baterías es que sus elementos son bastante voluminosos, y, al no ser tan populares como las LiPo, tampoco es demasiado fácil encontrar modelos de tamaño y capacidad adecuados en el mercado. 

\subsubsection{Elección y diseño del sistema}  

Por su tamaño y prestaciones se ha elegido la batería LiPo Rhino de 3S y 1750mAh que aparece en la figura \ref{lipo}. Esta batería tiene unas dimensiones perfectas para montarse en la cintura del robot y su peso (109 gramos) es mucho menor al de la batería original (215 gramos). 

\medskip A continuación se presenta una tabla (cuadro \ref{consumo}) con una estimación del consumo medio de todos los elementos seleccionados.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/lipo}   
\caption{Batería LiPo.}
\label{lipo}
\end{figure}
\FloatBarrier

\begin{table}[h]
\centering
\begin{tabular}{ >{\arraybackslash}m{2cm} >{\centering\arraybackslash}m{1.3cm}  >{\arraybackslash}m{5cm}  >{\arraybackslash}m{3cm}}
\hline
Dispositivo & Número & Consumo unitario & Consumo total  \\
\hline \hline
\medskip Dynamixel AX-12A \medskip & x19  & $11.1V\cdot600mA=6660mW$ & $126540mW$  \\ \hline
\medskip TowerPro MG90s \medskip & x1 & $5V\cdot120mA=600mW$ & $600mW$ \\ \hline
\medskip BeagleBone Black \medskip & x1 & $5V\cdot1200mA=6000mW$ & $6000mW$ \\ \hline
\medskip OpenCM 9.04 \medskip & x1 & $11.1V\cdot90mA\simeq1000mW$ & $1000mW$ \\ \hline 
\medskip Sharp IR \medskip &  x2 & $5V\cdot30mA=150mW$ & $300mW$ \\ \hline
\medskip MPU9150 \medskip & x1 & $3.3V\cdot15mA\simeq50mW$ & $50mW$ \\ \hline
\medskip HMC5883L \medskip &  x1  &  $3.3V\cdot12mA\simeq40mW$ & $40mW$ \\ \hline
\medskip Microsoft LifeCam \medskip & x1  &  $5V\cdot200mA=1000mW$ &  $1000mW$ \\ \hline \hline 
Total  &  &  & \medskip  $135530mW\simeq136W$ \medskip  \\ \hline
\hline
\end{tabular}
\caption{Consumo medio.}
\label{consumo}
\end{table}
\FloatBarrier


Por tanto, la estimación de autonomía del robot en funcionamiento es la siguiente:
\[ \dfrac{11.1V\cdot1750mAh}{135530mW}\cdot\dfrac{60min}{h}\simeq8.6min\]

Entre 8 y 9 minutos de autonomía teóricos es un buena cifra contando con el tamaño del robot y sus prestaciones. Como conclusión podemos remarcar el hecho de que gracias al nuevo sistema de alimentación hemos podido introducir los dispositivos necesarios para cumplir los requerimientos de este proyecto sin comprometer la autonomía del robot.

\subsection{Regulador de tensión}

Hasta aquí parece que es suficiente con la elección de la nueva batería, sin embargo, aún falta un detalle que deberemos resolver. La mayor parte de los dispositivos que forman el conjunto están alimentados a 5V. La batería que hemos elegido tiene una tensión de 11.1V, y se ha observado, que cuando está cargada al máximo desarrolla hasta 12.6V. No podemos alimentar la BeagleBone Black y el resto de componentes a una tensión tan alta, por lo que será necesario colocar un regulador que nos proporcione 5V.

\subsubsection{Regulador lineal}

La primera idea fue utilizar un pequeño circuito con un regulador lineal LM7805. El LM7805 es un componente muy común en los circuitos electrónicos, ya que ofrecen una salida de 5V a partir de tensiones de entrada de hasta 35V. En principio no parecería muy descabellado conectar los servos AX-12A  y la placa OpenCM directamente a la batería, y conectar en resto de componentes a través del regulador.

\medskip No obstante existen dos problemas para realizar este montaje. El primero es que la eficiencia de este componente es muy pobre, cercana al 60\% según su hoja de características. Esto provocaría una disminución drástica en el tiempo de operación del robot y una disipación de energia tan alta que sería necesario incluir un disipador. Pero el segundo problema es más importante, el componente está diseñado para aportar una corriente máxima al circuito de 1 amperio. Teniendo en cuenta los datos del cuadro \ref{consumo}, solo la BeagleBone Black ya requiere una corriente de 1.2A, y junto al resto de componentes, asciende hasta 1.7A . Un consumo superior al marcado por el fabricante puede producir fallos de funcionamiento en el componente. En este caso particular, podría producirse un calentamiento excesivo, que a su vez puede llegar a provocar cortocircuitos internos entre la patilla de entrada y la de salida. Las consecuencias de un fallo así serían nefastas, ya que deteriorarían los dispositivos conectados a él.

\subsubsection{Convertidor UBEC}

Un UBEC es un convertidor DC-DC de tipo reductor. El dispositivo se muestra en la figura \ref{ubec}. Los UBEC se utilizan normalmente con baterías de litio cuando el sistema necesita una tensión de alimentación de 5V o 6V. Es por ello que se utilizan mucho en receptores de emisoras de radiocontrol, y gracias a esto existe una amplia variedad de UBECs asequibles en el mercado. La mayor ventaja de estos circuitos convertidores es su eficiencia superior al 90\%. Gracias a esto nuestro sistema tendrá unas perdidas menores, no se calentará en exceso y gozará de una autonomía superior. 

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth]{figuras/ubec}   
\caption{Convertidor DC-DC comercial.}
\label{ubec}
\end{figure}
\FloatBarrier

\subsubsection{Elección final}

Tal y como se comentaba anteriormente, nuestro sistema tiene un consumo estimado de unos 1.7A en la salida de 5V, por lo que un UBEC de 3A sería suficiente para proporcionar al circuito la corriente necesaria para su funcionamiento. Adicionalmente se han incluido unos condensadores en la entrada y salida del circuito para evitar caídas bruscas de tensión debidas a requerimientos de intensidad anómalos. Este sistema nos proporcionará una distribución de alimentación correcta para todos los elementos del robot.